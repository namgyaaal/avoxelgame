:Namespace player
    ⎕IO ← 0
    cam_offset ← 1.45
    height ← 1.6
    half ← 0.3
    (x y z) ← 6 10 6
    (yaw pitch) ← 0 0
    gravity←¯6.1
    max_gravity←2×gravity
    speed←5
    vy ← gravity
    col_dirs← 0 0 0
    jump_power ← 6

    (e_w e_a e_s e_d) ← 0 0 0 0
    (e_mx e_my) ← 0 0

      Axis_check←{
          ⍝ ⍵ ←→ velocity where only one field is set, rest are 0
          ⍝ Returns vector (collision (velocity))
          min←(x y z)-(half 0 half) ⋄ max←(x y z)+(half height half)
          old←[min⋄max]

          ⍝ If ⍵>1 there is a chance that it will go through a block
          ⍝     to solve this: set v to s (sign) and recurse with ⍵-s
          ⍝     at (1) if it didn't hit anything until the end.
          ⍝ (there are probably better ways to sweep, but this works,
          ⍝     maybe look into this if become an issue: 
          ⍝     "continuous collision detection using swept AABB method and Minkowski sum")
          new←old(+⍤1)v←(s←×+/⍵)×1⌊|⍵
          Touch←{(⌊0⌷⍵)(+⍤1)↑,⍳(⌈1⌷⍵)-(⌊0⌷⍵)}
          m←{0≠⍵⌷##.world.chunks}¨##.world.Transform_points blks←new~⍥↓⍥Touch old
          (1<+/⍵)∧(~1∊m):∇⍵-s ⍝ (1)
          (~1∊m):0,⍵
          ⍝ Arbitrary block it intersects (can be any block!)
          blk←⊖↑(⊂1 1 1)∘+⍛, 0⌷blks
          cut←new((⌊⍥(1⌷⊢))-(⌈⍥(0⌷⊢))) blk
          ⍝ Modify vector by intersection distance into the block
          d←∊-s×cut/⍨0≠v
          (1×s), (⍵≠0)×d+v
      }

      Bound_check←{
        ⍝ ⍵ ←→ velocity
          v←⍵ ⋄ m←0⍴⍨,⍨≢v ⋄ (0 0⍉m)←v
          axis ← Axis_check¨↓m
          (x y z)+←1↓⊃+⌿axis
          col_dirs⊢←0⌷⍉↑axis
      }


    ∇ Input(w h)
      :If ##.LSE_CheckEvent ##.SDL_EVENT_KEY_DOWN
          :Select ⊃##.LSE_GetKeyPressed ⍬
          :Case ##.SDLK_W
              e_w←1
          :Case ##.SDLK_A
              e_a←1
          :Case ##.SDLK_S
              e_s←1
          :Case ##.SDLK_D
              e_d←1
          :Case ##.SDLK_SPACE
              :If ¯1=1⊃col_dirs
                vy←jump_power
              :EndIf
          :EndSelect
      :ElseIf ##.LSE_CheckEvent ##.SDL_EVENT_KEY_UP
          :Select ⊃##.LSE_GetKeyPressed ⍬
          :Case ##.SDLK_W
              e_w←0
          :Case ##.SDLK_A
              e_a←0
          :Case ##.SDLK_S
              e_s←0
          :Case ##.SDLK_D
              e_d←0
          :EndSelect
      :ElseIf ##.LSE_CheckEvent ##.SDL_EVENT_MOUSE_MOTION
          (e_mx e_my)←##.LSE_GetMouseMoveRel 0 0
      :EndIf
    ∇

    ∇ Update dt;v;look;forward;sideways
      (yaw pitch)-←dt×(e_mx e_my)
      pitch←1.59((-1.59)⌈⌊)pitch
      (e_mx e_my)←0 0
     
      vy←max_gravity⌈vy-dt×(0.5×|gravity)×speed
      look←Get_look_vec ⍬
      (forward sideways)←(e_w-e_s ⋄ e_d-e_a)
     
      v←dt×speed×forward×look
      v+←dt×speed×sideways×look ##.math.Cross 0 1 0
      (1⊃v)←0
      v+←dt×(0 vy 0)
      Bound_check v
    ∇

      Get_look_vec←{
          1 1 2○yaw pitch yaw
      }

      Get_view←{
          at←(x y z)+(0 cam_offset 0)
          l←Get_look_vec ⍬
          ##.math.Look_at at(at+l)(0 1 0)
      }
:EndNamespace
