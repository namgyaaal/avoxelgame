:Namespace player
    ⎕IO ← 0
    cam_offset ← 1.45
    height ← 1.6
    half ← 0.3
    (x y z) ← 6 50 6
    (yaw pitch) ← 0 0
    gravity←¯6.1
    max_gravity←2×gravity
    speed←5
    vy ← gravity
    col_y←0
    jump_power ← 6

    (e_w e_a e_s e_d e_jump) ← 0
    (e_place e_break) ← 0
    (e_mx e_my) ← 0

      Axis_check←{
          ⍝ ⍵ ←→ velocity where only one field is set, rest are 0
          ⍝ Returns vector (collision, velocity)
          min←(x y z)-(half 0 half) ⋄ max←(x y z)+(half height half)
          old←[min ⋄ max]
     
          ⍝ If ⍵>1 there is a chance that it will go through a block
          ⍝     to solve this: set v to s (sign) and recurse with ⍵-s
          ⍝     at (1) if it didn't hit anything until the end.
          ⍝ (there are probably better ways to sweep, but this works,
          ⍝     maybe look into this if become an issue:
          ⍝     "continuous collision detection using swept AABB method and Minkowski sum")
          new←old(+⍤1)v←(s←×+/⍵)×1⌊|⍵
          Touch←{(⌊0⌷⍵)(+⍤1)↑,⍳(⌈1⌷⍵)-(⌊0⌷⍵)}
          m←{0≠⍵⌷##.world.chunks}¨##.world.Transform_points blks←new~⍥↓⍥Touch old
          (1<+/⍵)∧(~1∊m):∇ ⍵-s ⍝ (1)
          (~1∊m):0,⍵
          ⍝ Arbitrary block it intersects (can be any block!)
          blk←⊖↑(⊂1 1 1)∘+⍛,0⌷blks
          cut←new((⌊⍥(1⌷⊢))-(⌈⍥(0⌷⊢)))blk
          ⍝ Modify vector by intersection distance into the block
          d←∊-s×cut/⍨0≠v
          s,(⍵≠0)×d+v+(⎕CT×-s)
      }

      Bound_check←{
        ⍝ ⍵ ←→ velocity
          v←⍵ ⋄ m←0⍴⍨,⍨≢v ⋄ (0 0⍉m)←v
          axis←Axis_check¨↓m
          (x y z)+←1↓⊃+⌿axis
          0⌷⍉↑axis
      }

      Break←{
          ⍝ ⍵ ←→ view vector
          (x y z)←⍵
          0=e_break:
          p←(x y z)##.Ray_hit 5×Get_look ⍬
          tp←##.world.Transform_points p
          m←{0≠⍵⌷##.world.chunks}¨tp
          0=∨/m:0
          blk←⊃m/tp
          (blk⌷##.world.chunks)←0
          ##.world.tb_queue,←(##.world.Cg'xz')⌷⍨⊃blk
          1
      }

      Place←{
        ⍝ ⍵ ←→ view vector
        ⍝ ⍺ ←→ block type
          ⍺←##.world.Bi'Wood'
          (x y z)←⍵
          0=e_place:
          p←(x y z)##.Ray_hit 5×Get_look ⍬
          tp←##.world.Transform_points p
          m←{0≠⍵⌷##.world.chunks}¨tp
          0=∨/m:0
          i←0⌈¯1+m⍳1
          blk←tp⊃⍨0⌈¯1+m⍳1
          (blk⌷##.world.chunks)←⍺
          ##.world.tb_queue,←(##.world.Cg'xz')⌷⍨⊃blk
          1
      }


    ∇ Input(w h);button
      :If ##.LSE_CheckEvent ##.SDL_EVENT_KEY_DOWN
          :Select ⊃##.LSE_GetKeyPressed ⍬
          :Case ##.SDLK_W
              e_w←1
          :Case ##.SDLK_A
              e_a←1
          :Case ##.SDLK_S
              e_s←1
          :Case ##.SDLK_D
              e_d←1
          :Case ##.SDLK_SPACE
              e_jump←1
          :EndSelect
      :ElseIf ##.LSE_CheckEvent ##.SDL_EVENT_KEY_UP
          :Select ⊃##.LSE_GetKeyPressed ⍬
          :Case ##.SDLK_W
              e_w←0
          :Case ##.SDLK_A
              e_a←0
          :Case ##.SDLK_S
              e_s←0
          :Case ##.SDLK_D
              e_d←0
          :EndSelect
      :ElseIf ##.LSE_CheckEvent ##.SDL_EVENT_MOUSE_MOTION
          (e_mx e_my)←##.LSE_GetMouseMoveRel 0 0
      :ElseIf ##.LSE_CheckEvent ##.SDL_EVENT_MOUSE_BUTTON_DOWN
          button←##.LSE_GetButton
     
          :If button=1
              e_break←1
          :ElseIf button=3
              e_place←1
          :EndIf
      :EndIf
    ∇

    ∇ Update dt;v;dir;forward;sideways;blks;m
      (yaw pitch)-←dt×(e_mx e_my)
      pitch←1.54((-1.54)⌈⌊)pitch
      (e_mx e_my)←0
     
      vy←max_gravity⌈vy-dt×(0.5×|gravity)×speed
      ⍝ 3 cases
      ⍝ (1) Able to jump
      ⍝ (2) On a block (don't go to max acceleration otherwise when falling off it'll zoom)
      ⍝     Set it to a bit of gravity
      ⍝ (3) Touching from jumping, set to 0
      ⍝ (3) Otherwise
      vy←{e_jump∧¯1=col_y:jump_power ⋄ ¯1=col_y:0.3×gravity ⋄ 1=col_y:0 ⋄ ⍵}vy
     
      dir←##.math.Norm 0@1⊢Get_look ⍬
      m←0≠(forward sideways)←(e_w-e_s ⋄ e_d-e_a)
      (forward sideways)←m×##.math.Norm(forward sideways)
     
      v←dt×speed×forward×dir
      v+←dt×speed×sideways×dir ##.math.Cross 0 1 0
      v+←dt×(0 vy 0)
      (_ col_y _)←Bound_check v
     
      Break(x ⋄ y+cam_offset ⋄ z)
      Place(x ⋄ y+cam_offset ⋄ z)
     
      (e_place e_break e_jump)←0
    ∇

      Get_look←{
          (×/1 2○yaw pitch ⋄ 1○pitch ⋄ ×/2 2○yaw pitch)
      }

      Get_view←{
          at←(x y z)+(0 cam_offset 0)
          l←Get_look ⍬
          ##.math.Look_at at(at+l)(0 1 0)
      }

      Get_frustum←{
          ⍝ ⍵ ←→ (fov, aspect ratio, znear, zfar)
          ⍝ Should be returned as (normals distance) as (6 4) matrix
          ⍝ (Near Far Right Left Top Bottom)
          (fov ⋄ ar ⋄ zn ⋄ zf)←⍵
          front←Get_look ⍬
          right←##.math.Norm front ##.math.Cross 0 1 0
          up←right ##.math.Cross front
          half_v_side←zf×(3○0.5×fov)
          half_h_side←half_v_side×ar
          front_mult_far←zf×front
     
          p←(x ⋄ y+cam_offset ⋄ z)
     
          p1←[
              p+zn×front
              p+front_mult_far
              p
              p
              p
              p
          ]
          normals←(##.math.Norm⍤¯1)[
              front
              -front
              (front_mult_far-right×half_h_side)##.math.Cross up
              up ##.math.Cross(front_mult_far+right×half_h_side)
              right ##.math.Cross(front_mult_far-up×half_v_side)
              (front_mult_far+up×half_v_side)##.math.Cross right
          ]
          distance←p1(+.×⍤¯1)normals
     
          normals,distance
      }


:EndNamespace
