:Namespace world
    ⎕IO ← 0
    l ← 16 128 16
    box ← ⊃∘.∨/1@0¨l-⍛↑¨1

    view_distance ← 8
    max_chunks ← 2*⍨1+2×view_distance

    ⍝ The maximum possible surface can be visualized as a
    ⍝   3d checkerboard. We need to also account for the edges
    ⍝   of the chunk
    ⍝ This is:
    ⍝  6×⌈2÷⍨×/¯2+l    - Inner
    ⍝  6×(×/-×/⍤-∘2)l  - Outer
    max_faces ← 6×⌈2÷⍨×/¯2+l
    max_faces +← 6×(×/-×/⍤-∘2) l

    ⍝ For each face we need 4 vertices and 6 indices
    ⍝ Furthermore, we need the amount of info per vertex and size of indices
    (vsize isize) ← (4×4×max_faces ⋄ 4×6×max_faces)

    vb_sizes ← ⌈0 0.35 0.7 1.0 × vsize
    vb_pools ← ⍬ ⍬ ⍬
    vb_start_lens ← ⌊1.0 0.1 0.1×max_chunks

    ⍝ vbs that aren't done being used by the gpu
    ⍝ (fence counter, index into vb_pools, vb pointer)
    ⍝ freed vbs are added with fence pointer 0 and when fence is
    ⍝   retrieved, they're set with func Push_fence.
    ⍝ Released with Pop_fence
    vb_fenced ← 0 3⍴0

    ib ← 0
    tb ← 0
    tb_pos ← 0
    tb_size ← 2×vsize
    ⍝ Vector of x and z positions corresponding to xz column
    tb_queue ← ⍬
    (texture sampler) ← ⍬ ⍬

    chunks ← 0⍴⍨0,l
    cnames ← 'xz' 'vb' 'vb_kind' 'idx_cnt' 'ready'
    chunk_info ← 0⍴⍨0, ≢cnames
    chunks_rendered←0


    I←⌷⍨∘⊃⍨⍤0 99
    ⍝ Chunk column index (Only used with one entry)
    Ci ← cnames∘⍳∘⊂
    ⍝ Chunk get
    Cg ← {chunk_info⌷[1]⍨Ci⍵}
    ⍝ Chunk get cell (Where ⍺ = row #, ⍵ = column name)
    Cgc ← {chunk_info⌷⍨⍺,Ci⍵}
    ⍝ Chunk column lookup (Where ⍺ = entries, ⍵ = column name)
    Cl ← {⍺ (≡⍤0) chunk_info⌷[1]⍨Ci⍵}

    faces ← [
    0 1 0 ⋄ 0 1 1 ⋄ 0 0 1 ⋄ 0 0 0 ⍝ Left
    1 1 1 ⋄ 1 1 0 ⋄ 1 0 0 ⋄ 1 0 1 ⍝ Right
    1 0 0 ⋄ 0 0 0 ⋄ 0 0 1 ⋄ 1 0 1 ⍝ Bottom
    0 1 0 ⋄ 1 1 0 ⋄ 1 1 1 ⋄ 0 1 1 ⍝ Top
    1 1 0 ⋄ 0 1 0 ⋄ 0 0 0 ⋄ 1 0 0 ⍝ Back
    0 1 1 ⋄ 1 1 1 ⋄ 1 0 1 ⋄ 0 0 1 ⍝ Front
    ]
    v_cnt ← ≢faces

    ⍝ From ⍳-vertex count in shape of l:
    ⍝ - Extend into 3d coordinate space with ⊤
    ⍝ - Transpose into format where position is last and insert rank
    ⍝ - Replicate added rank by number of vertices in a cube
    ⍝ - Add cube vertices to extend each position
    ⍝ - Join in the form (Vertices, 3) so that color/uv/etc can be cated
    vertices ← ,[⍳4] faces(+⍤2) v_cnt(⌿⍤2),[2.5] 3 0 1 2⍉l⊤⊢l⍴⍳×/l
    indices←,0 1 2 0 2 3∘.+⍨4×⍳4÷⍨≢vertices


    lattice←⌊10+25×?129 129⍴0
    ⍝l←⊃⌽⍴lattice
⍝t←1(-,[0.5]⊢)1|⍉c⋄+⌿(⊣⌿t)×(⊢⌿t)+⌿⍤×⍤2⊢(,lattice)[(l×⍳2)∘.+(⍳2)∘.+l⊥(⍳4)⍸⍤1⍉c]

      Transform_points←{
          ⍝ ⍵ ←→ vector of integers 3d space
          ⍝ ⍺ ←→ filter out invalid ones (default true)
          ⍝ returns them in terms of locations into 4d chunk matrix
          ⍺←1
          0=≢⍵:⍬
          coords←⌊l[0]÷⍨(⊂0 2)∘⌷¨⍵
          cindices←coords⍳⍨Cg'xz'
          ⍺∘{(~⍺)∨0≤2⊃⍵}¨⍛/cindices,¨((⊃l)∘|@(0 2)⊢)¨⍵
      }

      Fetch_buffer←{
          ⍝ ⍺ ←→ GPU Device
          ⍝ ⍵ ←→ Pool Index
          ⍝ Note: either return it back to the vector or destroy it
          ⍝ Memory leak otherwise
          0<≢⍵⊃vb_pools:{o←⊃⍵⊃vb_pools ⋄ (⍵⊃vb_pools)↓⍨←1 ⋄ o}⍵
          vb←##.SDL_CreateGPUBuffer device(##.SDL_GPU_BUFFERUSAGE_VERTEX(⍵⊃1↓vb_sizes)0)
          0=vb:'Error creating vertex buffer'##.Assert vb
          vb
      }

      Push_fence←{
          ⍝ ⍵ ←→ Fence counter
          0=≢vb_fenced:
          m←¯1=0⌷⍉vb_fenced
          (m/0⌷⍉vb_fenced)←⍵
      }

      Pop_fences←{
          ⍝ ⍵ ←→ Fence counters
          0=≢vb_fenced:
          m←⍵∊⍨0⌷⍉vb_fenced
          kinds←1⌷⍉vb_fenced
          vbs←2⌷⍉vb_fenced
          vb_fenced⌿⍨←~m
          _←kinds{(⍺⊃vb_pools),←⍵}⌸⍥{m/⍵}vbs
      }

    ∇ Init device;vb_params;tb_params;p;cmd;pass;sam_params;w;h;pitch;addr;size
      vb_pools←{
          (cnt size)←⍵
          vb_params←##.SDL_GPU_BUFFERUSAGE_VERTEX size 0
          ({⍵,##.SDL_CreateGPUBuffer device vb_params}⍣cnt)⍬
      }¨↓⍉[vb_start_lens ⋄ 1↓vb_sizes]
     
      tb_params←⊂##.SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD(tb_size)0
      tb←##.SDL_CreateGPUTransferBuffer device tb_params
      'Error creating chunk transfer buffer'##.Assert tb
      ib←##.SDL_CreateGPUBuffer device(##.SDL_GPU_BUFFERUSAGE_INDEX isize 0)
     
      sam_params←⊂0 0 0 2 2 2 0 4 0 0 200 1 0 0 0 0
      sampler←##.SDL_CreateGPUSampler device sam_params
      'Error creating chunk sampler'##.Assert sampler
      ⍝ Do copy pass just to copy index buffer over
      ⍝ Only need isize worth of indices by reasoning
      ⍝ Overhead should be minimal if this is done once
      p←##.SDL_MapGPUTransferBuffer device tb 0
      _←##.LSE_MemcpyU32 p(indices)isize
      _←##.SDL_UnmapGPUTransferBuffer device tb
      cmd←##.SDL_AcquireGPUCommandBuffer device
      pass←##.SDL_BeginGPUCopyPass cmd
     
      _←##.SDL_UploadToGPUBuffer pass(tb 0)(ib 0 isize)0
      _←##.SDL_EndGPUCopyPass pass
      _←##.SDL_SubmitGPUCommandBuffer cmd
    ∇

    ∇ Release device
      {_←##.SDL_ReleaseGPUBuffer device ⍵}¨∊vb_pools,(2⌷⍉vb_fenced),Cg'vb'
      _←##.SDL_ReleaseGPUBuffer device ib
      _←##.SDL_ReleaseGPUBuffer device tb
     
      _←##.SDL_ReleaseGPUSampler device sampler
    ∇

    ∇ Queue_chunk(device blocks trans);x;z;vb
      (x z)←trans
      chunk_info⍪←(⊂x z),0⍴⍨¯1+≢cnames
      chunks⍪←blocks
      tb_queue,←⊂x z
    ∇

    ∇ info←Copy_chunk(chunk ptr offset);flat;solid;edges;exposed;m;vert;tex;buf;vs;ic
      ⍝ Collapse chunk @ x z and write it to ptr
      ⍝ Return vertex size in bytes and number of indices
      ⍝ IMPORTANT: Assumes that where data is being written to has enough space
      flat←∊chunk
      solid←chunk≠0
      edges←solid∧box
      ⍝ (1) Returns format (16 32 16 3 2) where (3 2) are rotations
      ⍝ (2) collapse into (vertex_num 6) multiply by index where not 0
      ⍝ (3) index into box and 6wise multiply+⍳add for texture index
      ⍝ (4) index into texture and select exposed faces, duplicate 4 for faces
      ⍝ (5) do some bitpacking here. Since we know x z ∊ [0, 16], they only take 5 bits
      ⍝     use the leading bit for uv coordinate into 4 corners (hence adding 128)
      ⍝     with this we only need 4 bytes for a vertex
      exposed←↑[0]{edges∨solid>⍵}¨0 1 2∘.{⍵⌽[⍺]solid}¯1 1  ⍝ (1)
      vert←vertices⌿⍨4/m←∊exposed
      tex←(⍳×/l)(×⍤¯1),[1+⍳2],[⍳3]exposed                  ⍝ (2)
      tex←∊(⍳6)(+⍤1)6×flat[tex]                            ⍝ (3)
      tex←4/m/,##.block_data.tex_z[tex]                    ⍝ (4)
      vert+←(3,⍨≢vert)⍴128×[0 0 0 ⋄ 0 0 1 ⋄ 1 0 1 ⋄ 1 0 0] ⍝ (5)
      buf←∊vert,tex
      vs←≢buf
      ic←6×4÷⍨≢vert
      _←##.LSE_MemcpyU8(ptr+offset)buf vs
      info←vs ic
    ∇

    ∇ Copy_chunks(device pass);m;p;vb;vi;vk;idxs;copied_info;dirty_m;null_m;vbs;xzs;sort
      :If 0=≢tb_queue
          :Return
      :EndIf
      tb_pos←0

      
      ⍝ Copy into transfer buffer until full or queue is empty
      p←##.SDL_MapGPUTransferBuffer device tb 1

      tb_queue/⍨←tb_queue∊Cg'xz'
      idxs←tb_queue⍳⍨Cg'xz'
      
      ⍝ Copied info in total will be:
      ⍝.   (position into transfer buffer, vertex size, index count, vertex kind, vertex buffer)
      copied_info←{
          (vs ic)←Copy_chunk(chunks⌷⍨idxs⊃⍨≢⍵ ⋄ p ⋄ tb_pos)
          pos←tb_pos ⋄ tb_pos+←vs
          ⍵⍪(pos vs ic)
      }⍣{(tb_size≤tb_pos+vsize)∨⍺≥⍥≢idxs}⊢0 3⍴0
      _←##.SDL_UnmapGPUTransferBuffer device tb

     
      ⍝ Add vertex kinds (vb pool index)
      copied_info,←vb_sizes∘⍸¨1⌷⍉copied_info
     
      idxs↑⍨←≢copied_info
      m←idxs∊⍨⍳≢chunk_info
      ⍝ Since queue and chunk)info are unsorted and might assign in a
      ⍝     different order, need to sort what has been selected from the
      ⍝     queue with what it's being assigned to
      sort←(⊂⍋⍋m/Cg'xz')⌷⍋tb_queue↑⍨≢copied_info
      copied_info←(⊂sort)⌷copied_info
      tb_queue↓⍨←≢copied_info
     
      dirty_m←m∧0≠Cg'vb'
      vb_fenced⍪←¯1,'vb_kind'{⍉↑⍺ ⍵}⍥{⍵/⍨dirty_m}⍥Cg'vb'

      vbs←device∘Fetch_buffer¨3⌷⍉copied_info
      copied_info,←vbs

      ⍝ GPU Upload and set loaded chunks as ready with render info
      {(pos vs _ _ vb)←⍵⋄ _←##.SDL_UploadToGPUBuffer pass(tb pos)(vb 0 vs)0}¨↓copied_info
      (m/(Ci'idx_cnt')⌷⍉chunk_info)←2⌷⍉copied_info
      (m/(Ci'vb')⌷⍉chunk_info)←vbs
      (m/(Ci'vb_kind')⌷⍉chunk_info)←3⌷⍉copied_info
      (m/(Ci'ready')⌷⍉chunk_info)←1

    ∇

    ∇ Update_range(device x z);range;new;old;m;pair;blocks;c;t;idx;set_m
      range←(⊂⌊16÷⍨x z)+,∘.,⍨(⍳1+2×view_distance)-view_distance
      new←range~Cg'xz'
      old←range~⍨Cg'xz'

      chunks⌿⍨←m←~old∊⍨Cg'xz'
      ⍝ unload chunks
      set_m ← (0≠Cg'vb')∧~m
      vb_fenced⍪←¯1,'vb_kind'{⍉↑⍺ ⍵}⍥{⍵/⍨set_m}⍥Cg'vb'

      chunk_info⌿⍨←m
      
      :For pair :In new
        c←(16÷⍨0.5+16 16⊤⍳16*2)(+⍤1 0)128||pair
        t←t←1(-,[0.5]⊢)1|c
        idx←⌊+⌿(⊣⌿t)×(⊢⌿t)+⌿⍤×⍤2⊢(,lattice)[(128×⍳2)∘.+(⍳2)∘.+128⊥⌊c]
        idx←128-idx
        blocks←l⍴0
        blocks[↓(16/⍳16),(⍪idx),(256 1⍴⍳16)] ← 1
        blocks ← ⊖⍤2∨⍀⍤2⊢blocks
        Queue_chunk device blocks pair
      :EndFor
∇
      ⍝{Queue_chunk device blocks ⍵}¨new
      ⍝:For pair :In new
      ⍝    blocks←l⍴0
      ⍝    ⍝ Testing different vb_pool
      ⍝    :If 0.95<?0
      ⍝        _←{w←⍵+⍳16-2×⍵ ⋄ blocks[w;1+ground+⍵;w]←6 ⋄ ⍵+1}⍣8⊢0
      ⍝    :Else
      ⍝        blocks[;⍳ground;]←2
      ⍝        blocks[;ground;]←1
      ⍝        ⍝ Tree :)
      ⍝        :If 0.6<?0
      ⍝            tx tz←4+?10 10
      ⍝            ty←3+?3
      ⍝            blocks[tx;ground+⍳ty;tz]←4
      ⍝            blocks[tx+¯2+⍳5;(ground ⋄ ground+1)+ty;tz+¯2+⍳5]←5
      ⍝            blocks[tx+¯1+⍳3;(ground+2 ⋄ ground+3)+ty;tz+¯1+⍳3]←5
      ⍝        :EndIf
      ⍝    :EndIf
      ⍝ 
      ⍝    Queue_chunk device blocks pair
      ⍝:EndFor
   

    ∇ Draw_chunks(cmd_buf pass px pz lx lz proj_view);w;m;vbs;inds;xz;ud;frs;n;d;box;h;t;t2;centers;extents;r
      ⍝ Frustum Culling
      frs←##.player.Get_frustum(○70÷180 ⋄ 1280÷720 ⋄ 0.1 ⋄ 500)
      n←3↑[1]frs
      d←,3↓[1]frs
     
      ⍝ https://web.archive.org/web/20220115111822/https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_plane.html
      centers←(w÷2 ⋄ 2÷⍨h←1⊃l ⋄ w÷2)(+⍤1)⌽2⌽0,(w←⊃l)×↑Cg'xz'
      r←+/(|n)(×⍤1)(w ⋄ h ⋄ w)÷2
      m←(Cg'ready')∧∧/(-r)(≤⍤1)d(-⍤1)⍨n(+.×⍤2 1)centers
     
      chunks_rendered←+/m
      vbs←m/Cg'vb'
      inds←m/Cg'idx_cnt'
      ⍝ Translation matrix for each chunk and rank-multiply to get MVPs for each
      ud←∊proj_view(+.×⍤2)⍨⊃⍪/{(x z)←⍵ ⋄ ,[¯0.5](x 0 z 1)@3⊢∘.=⍨⍳4}¨(⊃l)×m/Cg'xz'
      _←##.SDL_BindGPUFragmentSamplers pass 0(⊂##.block_data.texture sampler)1
      _←##.SDL_BindGPUIndexBuffer pass(⊂ib 0)##.SDL_GPU_INDEXELEMENTSIZE_32BIT
      _←##.LSE_DrawListWithPushConstants cmd_buf pass vbs inds(≢vbs)ud 0 16
    ∇
:EndNamespace
