:Namespace world
    ⎕IO ← 0
    l ← 16 32 16
    box ← ⊃∘.∨/1@0¨l-⍛↑¨1

    ⍝ The maximum possible surface can be visualized as a
    ⍝   3d checkerboard. We need to also account for the edges
    ⍝   of the chunk
    ⍝ This is:
    ⍝  6×⌈2÷⍨×/¯2+l    - Inner
    ⍝  6×(×/-×/⍤-∘2)l  - Outer
    max_faces ← 6×⌈2÷⍨×/¯2+l
    max_faces +← 6×(×/-×/⍤-∘2) l

    ⍝ For each face we need 4 vertices and 6 indices
    ⍝ Furthermore, we need the amount of info per vertex
    ⍝ and size of vertex and index values (f32, u32)
    (vsize isize) ← (4×5×4×max_faces ⋄ 4×6×max_faces)

    vb_pool ← ⍬
    ib ← 0
    tb ← 0
    tb_pos ← 0
    tb_size ← 10×vsize
    tb_queue ← ⍬
    (texture sampler) ← ⍬ ⍬


    chunks ← 0⍴⍨0,l
    cnames ← 'xz' 'vb' 'idx_cnt' 'ready'
    chunk_info ← 0⍴⍨0, ≢cnames

    view_distance ← 5

    I←⌷⍨∘⊃⍨⍤0 99
    ⍝ Chunk column index (Only used with one entry)
    Ci ← cnames∘⍳∘⊂
    ⍝ Chunk get
    Cg ← {chunk_info⌷[1]⍨Ci⍵}
    ⍝ Chunk get cell (Where ⍺ = row #, ⍵ = column name)
    Cgc ← {chunk_info⌷⍨⍺,Ci⍵}
    ⍝ Chunk column lookup (Where ⍺ = entries, ⍵ = column name)
    Cl ← {⍺ (≡⍤0) chunk_info⌷[1]⍨Ci⍵}


    faces ← [
    0 1 0 ⋄ 0 1 1 ⋄ 0 0 1 ⋄ 0 0 0 ⍝ Left
    1 1 1 ⋄ 1 1 0 ⋄ 1 0 0 ⋄ 1 0 1 ⍝ Right
    1 0 0 ⋄ 0 0 0 ⋄ 0 0 1 ⋄ 1 0 1 ⍝ Bottom
    0 1 0 ⋄ 1 1 0 ⋄ 1 1 1 ⋄ 0 1 1 ⍝ Top
    1 1 0 ⋄ 0 1 0 ⋄ 0 0 0 ⋄ 1 0 0 ⍝ Back
    0 1 1 ⋄ 1 1 1 ⋄ 1 0 1 ⋄ 0 0 1 ⍝ Front
    ]
    v_cnt ← ≢faces

    textures ← (
        ⍝ Air (Here for easy indexing, filtered out)
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
        ⍝ Grass
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.2 ⋄ 0.6 0.2]
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.2 ⋄ 0.6 0.2]
    [0.4 0.0 ⋄ 0.6 0.0 ⋄ 0.6 0.2 ⋄ 0.4 0.2]
    [0.0 0.0 ⋄ 0.2 0.0 ⋄ 0.2 0.2 ⋄ 0.0 0.2]
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.2 ⋄ 0.6 0.2]
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.2 ⋄ 0.6 0.2]
        ⍝ Stone
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.2 ⋄ 0.2 0.2]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.2 ⋄ 0.2 0.2]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.2 ⋄ 0.2 0.2]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.2 ⋄ 0.2 0.2]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.2 ⋄ 0.2 0.2]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.2 ⋄ 0.2 0.2]
        ⍝ Wood
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.2 ⋄ 0.8 0.2]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.2 ⋄ 0.8 0.2]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.2 ⋄ 0.8 0.2]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.2 ⋄ 0.8 0.2]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.2 ⋄ 0.8 0.2]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.2 ⋄ 0.8 0.2]
        ⍝ Log
    [0.8 0.2 ⋄ 1.0 0.2 ⋄ 1.0 0.4 ⋄ 0.8 0.4]
    [0.8 0.2 ⋄ 1.0 0.2 ⋄ 1.0 0.4 ⋄ 0.8 0.4]
    [0.8 0.2 ⋄ 1.0 0.2 ⋄ 1.0 0.4 ⋄ 0.8 0.4]
    [0.8 0.2 ⋄ 1.0 0.2 ⋄ 1.0 0.4 ⋄ 0.8 0.4]
    [0.8 0.2 ⋄ 1.0 0.2 ⋄ 1.0 0.4 ⋄ 0.8 0.4]
    [0.8 0.2 ⋄ 1.0 0.2 ⋄ 1.0 0.4 ⋄ 0.8 0.4]
        ⍝ Leaf
    [0.0 0.4 ⋄ 0.2 0.4 ⋄ 0.2 0.6 ⋄ 0.0 0.6]
    [0.0 0.4 ⋄ 0.2 0.4 ⋄ 0.2 0.6 ⋄ 0.0 0.6]
    [0.0 0.4 ⋄ 0.2 0.4 ⋄ 0.2 0.6 ⋄ 0.0 0.6]
    [0.0 0.4 ⋄ 0.2 0.4 ⋄ 0.2 0.6 ⋄ 0.0 0.6]
    [0.0 0.4 ⋄ 0.2 0.4 ⋄ 0.2 0.6 ⋄ 0.0 0.6]
    [0.0 0.4 ⋄ 0.2 0.4 ⋄ 0.2 0.6 ⋄ 0.0 0.6]
    )
    ⍝ From ⍳-vertex count in shape of l:
    ⍝ - Extend into 3d coordinate space with ⊤
    ⍝ - Transpose into format where position is last and insert rank
    ⍝ - Replicate added rank by number of vertices in a cube
    ⍝ - Add cube vertices to extend each position
    ⍝ - Join in the form (Vertices, 3) so that color/uv/etc can be cated
    vertices ← ,[⍳4] faces(+⍤2) v_cnt(⌿⍤2),[2.5] 3 0 1 2⍉l⊤⊢l⍴⍳×/l
    indices←,0 1 2 0 2 3∘.+⍨4×⍳4÷⍨≢vertices

      Transform_points←{
          coords←⌊l[0]÷⍨(⊂0 2)∘⌷¨⍵
          cindices←coords⍳⍨Cg'xz'
          cindices,¨16|⍵
      }

    ∇ Init_chunks device;vb_params;tb_params;p;cmd;pass;tex_params;sam_params;img;surface;w;h;pitch;addr;size
      vb_params←##.SDL_GPU_BUFFERUSAGE_VERTEX vsize 0
      vb_pool←({⍵,##.SDL_CreateGPUBuffer device vb_params}⍣100)⍬
      'Error creating vertex buffer pool'##.Assert vb_pool
     
      tb_params←⊂##.SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD(tb_size)0
      tb←##.SDL_CreateGPUTransferBuffer device tb_params
      'Error creating chunk transfer buffer'##.Assert tb
      ib←##.SDL_CreateGPUBuffer device(##.SDL_GPU_BUFFERUSAGE_INDEX isize 0)
     
      img←##.IMG_Load⊂'assets/blocks.bmp'
      ⍝ Magic number for 8 8 8 8 A B G R texture
      surface←##.SDL_ConvertSurface img 376840196
      'Error loading chunk image'##.Assert img surface
      ##.SDL_DestroySurface img
     
      (w h pitch _)←##.LSE_GetSurfaceParams surface 0 0 0 0
      addr←##.LSE_GetSurfaceDataAddress surface
      size←pitch×h
     
      sam_params←⊂0 0 0 2 2 2 0 0 0 0 100 0 0 0 0 0
      tex_params←⊂0 ##.SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM 3 w h 1 4 0 0
     
      sampler←##.SDL_CreateGPUSampler device sam_params
      texture←##.SDL_CreateGPUTexture device tex_params
      ##.SDL_SetGPUTextureName device texture'Chunk texture'
      'Error creating chunk texture and sampler'##.Assert sampler texture
     
      tex_params←⊂##.SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD
     
      ⍝ Do copy pass just to copy index buffer over
      ⍝ Only need isize worth of indices by reasoning
      ⍝ Overhead should be minimal if this is done once
      p←##.SDL_MapGPUTransferBuffer device tb 0
      ##.LSE_MemcpyU32 p(indices)isize
      ⍝ Have enough in it to also pack in textures?
      ##.SDL_memcpy(p+isize)(addr)size
      ##.SDL_UnmapGPUTransferBuffer device tb
      cmd←##.SDL_AcquireGPUCommandBuffer device
      pass←##.SDL_BeginGPUCopyPass cmd
     
     
      ##.SDL_UploadToGPUBuffer pass(tb 0)(ib 0 isize)0
      ##.SDL_UploadToGPUTexture pass(tb isize 0 0)(texture 0 0 0 0 0 w h 1)0
      ##.SDL_EndGPUCopyPass pass
      ##.SDL_GenerateMipmapsForGPUTexture cmd texture
      ##.SDL_SubmitGPUCommandBuffer cmd
      ##.SDL_DestroySurface surface
    ∇

    ∇ Delete device
      ##.SDL_ReleaseGPUTexture device texture
      ##.SDL_ReleaseGPUSampler device sampler
    ∇

    ∇ Queue_chunk(device blocks trans);x;z;vb
      (x z)←trans
     
      :If 0<≢vb_pool
          vb←1↑vb_pool
          vb_pool←1↓vb_pool
      :Else
          vb←##.SDL_CreateGPUBuffer device(##.SDL_GPU_BUFFERUSAGE_VERTEX vsize 0)
          'Error creating vertex buffer'##.Assert vb
      :EndIf
      chunk_info⍪←(x z)vb 0 0
      chunks⍪←blocks
      tb_queue,←⊂x z
    ∇

    ∇ info←Copy_chunk(chunk tx tz ptr offset);tx;tz;flat;solid;edges;exposed;vert;tex;buf;vs;ic
      ⍝ Collapse chunk @ x z and write it to ptr
      ⍝ Return vertex size in bytes and number of indices
      ⍝ IMPORTANT: Assumes that where data is being written to has enough space
      flat←∊chunk
      solid←chunk≠0
      edges←solid∧box
      exposed←↑[0]{edges∨solid>⍵}¨0 1 2∘.{⍵⌽[⍺]solid}¯1 1
      vert←(tx 0 tz)(+⍤1)vertices⌿⍨4/∊exposed
      tex←(⍳×/l)(×⍤¯1),[1+⍳2],[⍳3]exposed
      tex←(⍳6)(+⍤1)6×flat[tex]
      tex←,[⍳2]↑(∊exposed)/,textures[tex]
      buf←∊vert,tex
      vs←4×≢buf
      ic←6×4÷⍨≢vert
      ##.LSE_MemcpyF32(ptr+offset)buf vs      
      info←vs ic
    ∇

    ∇ Copy_chunks(device pass);idx;q;x;z;tx;tz;m;is;tex;buf;vs;ic;p;pos;i;vb
      tb_pos←0
      q←⍬
      p←##.SDL_MapGPUTransferBuffer device tb 1
      :While (tb_size>tb_pos+vsize)∧(0≠≢tb_queue)
          (x z)←⊃1↑tb_queue
          idx←⊃⍸(⊂x z)Cl'xz'
          (tx tz)←(x z)×(⊂0 2)⌷l
          (vs ic)←Copy_chunk (idx⌷chunks) tx tz p tb_pos
     
          q,←⊂tb_pos vs ic idx
          tb_queue←1↓tb_queue
          tb_pos+←vs
      :EndWhile
      ##.SDL_UnmapGPUTransferBuffer device tb
     
      :For (pos vs ic i) :In q
          vb←i Cgc'vb'
          ##.SDL_UploadToGPUBuffer pass(tb pos)(vb 0 vs)1
          ((i,Ci'idx_cnt')⌷chunk_info)←ic
          ((i,Ci'ready')⌷chunk_info)←1
      :EndFor
    ∇

    ∇ Update_range(device x z);range;dist;new;old;m;pair;tx;tz;ty
      range←,∘.,⍨((-view_distance)+⍳1+2×view_distance)
      range←(⊂x z)+range/⍨∊view_distance≥0.5*⍨+/¨range*2
     
      new←range~Cg'xz'
      old←range~⍨Cg'xz'
     
      chunks←chunks⌿⍨m←~old∊⍨Cg'xz'
      vb_pool,←(~m)/Cg'vb'
      chunk_info←m⌿chunk_info

      :For pair :In new
          blocks←l⍴0
          blocks[;0;]←1
          ⍝ Tree :)
          tx tz←4+?10 10
          ty←3+?3
          blocks[tx;1+⍳ty;tz]←4
          blocks[tx+¯2+⍳5;1 2+ty;tz+¯2+⍳5]←5
          blocks[tx+¯1+⍳3;3 4+ty;tz+¯1+⍳3]←5
          Queue_chunk device blocks pair
      :EndFor
    ∇

    ∇ Draw_chunks(device pass px pz lx lz);vec;dist;num;den;m;vbs;inds
      vec←(⊂px pz)-⍨Cg'xz'
      dist←0.5*⍨+/¨vec*2
      num ← (lx lz) (+.×⍤1) ↑vec
      den ← dist × 0.5*⍨+/(lx lz)*2 
      ⍝ Filter out zero-dist chunk and re-add
      m←(0≠den)∧Cg'ready'
      (m/m)←(○0.8)>¯2○(m⌿num)÷(m⌿den)
      m←(Cg'ready')∧(m∨0=den)
      vbs←m/Cg'vb'
      inds←m/Cg'idx_cnt'

      ##.SDL_BindGPUFragmentSamplers pass 0(⊂texture sampler)1
      ##.SDL_BindGPUIndexBuffer pass(⊂ib 0)##.SDL_GPU_INDEXELEMENTSIZE_32BIT
      ##.LSE_DrawList pass vbs inds(≢vbs)
    ∇

:EndNamespace
