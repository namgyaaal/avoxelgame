:Namespace chunk
    ⎕IO ← 0
    l ← 16 17 16
    box ← ⊃∘.∨/1@0¨l-⍛↑¨1
    tb ← 0


    ⍝ The maximum possible surface can be visualized as a
    ⍝   3d checkerboard. We need to also account for the edges
    ⍝   of the chunk
    ⍝ This is:
    ⍝  6×⌈2÷⍨×/¯2+l    - Inner
    ⍝  6×(×/-×/⍤-∘2)l  - Outer

    max_faces ← 6×⌈2÷⍨×/¯2+l
    max_faces +← 6×(×/-×/⍤-∘2) l

    ⍝ For each face we need 4 vertices and 6 indices
    ⍝ Furthermore, we need the amount of info per vertex
    ⍝ and size of vertex and index values (f32, u32)
    (vsize isize) ← (4×5×4×max_faces ⋄ 4×6×max_faces)
    tb_size ← 10×(vsize + isize)
    tb_queue ← ⍬

    cnames ← 'vb' 'ib' 'idx_cnt'
    chunks ← 0 3⍴0

    faces ← [
    0 1 0 ⋄ 0 1 1 ⋄ 0 0 1 ⋄ 0 0 0 ⍝ Left
    1 1 1 ⋄ 1 1 0 ⋄ 1 0 0 ⋄ 1 0 1 ⍝ Right
    1 0 0 ⋄ 0 0 0 ⋄ 0 0 1 ⋄ 1 0 1 ⍝ Bottom
    0 1 0 ⋄ 1 1 0 ⋄ 1 1 1 ⋄ 0 1 1 ⍝ Top
    1 1 0 ⋄ 0 1 0 ⋄ 0 0 0 ⋄ 1 0 0 ⍝ Back
    0 1 1 ⋄ 1 1 1 ⋄ 1 0 1 ⋄ 0 0 1 ⍝ Front
    ]
    v_cnt ← ≢faces

    textures ← (
        ⍝ Air (Here for easy indexing, filtered out)
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
    [0 0 ⋄ 0 0 ⋄ 0 0 ⋄ 0 0]
        ⍝ Grass
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.5 ⋄ 0.6 0.5]
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.5 ⋄ 0.6 0.5]
    [0.4 0.0 ⋄ 0.6 0.0 ⋄ 0.6 0.5 ⋄ 0.4 0.5]
    [0.0 0.0 ⋄ 0.2 0.0 ⋄ 0.2 0.5 ⋄ 0.0 0.5]
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.5 ⋄ 0.6 0.5]
    [0.6 0.0 ⋄ 0.8 0.0 ⋄ 0.8 0.5 ⋄ 0.6 0.5]
        ⍝ Stone
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.5 ⋄ 0.2 0.5]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.5 ⋄ 0.2 0.5]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.5 ⋄ 0.2 0.5]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.5 ⋄ 0.2 0.5]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.5 ⋄ 0.2 0.5]
    [0.2 0.0 ⋄ 0.4 0.0 ⋄ 0.4 0.5 ⋄ 0.2 0.5]
        ⍝ Wood
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.5 ⋄ 0.8 0.5]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.5 ⋄ 0.8 0.5]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.5 ⋄ 0.8 0.5]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.5 ⋄ 0.8 0.5]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.5 ⋄ 0.8 0.5]
    [0.8 0.0 ⋄ 1.0 0.0 ⋄ 1.0 0.5 ⋄ 0.8 0.5]
    )
    ⍝ From ⍳-vertex count in shape of l:
    ⍝ - Extend into 3d coordinate space with ⊤
    ⍝ - Transpose into format where position is last and insert rank
    ⍝ - Replicate added rank by number of vertices in a cube
    ⍝ - Add cube vertices to extend each position
    ⍝ - Join in the form (Vertices, 3) so that color/uv/etc can be cated
    vertices ← ,[⍳4] faces(+⍤2) v_cnt(⌿⍤2),[2.5] 3 0 1 2⍉l⊤⊢l⍴⍳×/l

    ∇ Init_chunks device;tb_params
      tb_params←⊂#.SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD(tb_size)0
      tb←#.SDL_CreateGPUTransferBuffer device tb_params
      'Error creating chunk transfer buffer'#.Assert tb
    ∇

    ∇ Create_chunk(device blocks trans);flat;solid;edges;rot;exposed;vert;ind;tex;buf;p;vb;ib;skip
      flat←∊blocks
      solid←blocks≠0
      edges←solid∧box
      rot←0 1 2∘.{⍵⌽[⍺]solid}¯1 1
      exposed←↑[0]{edges∨solid>⍵}¨rot
     
      vert←trans(+⍤1)vertices⌿⍨4/∊exposed
      ⍝vert ← (4/∊exposed)⌿vertices
      ind←,0 1 2 0 2 3∘.+⍨4×⍳4÷⍨≢vert
      tex←(⍳×/l)(×⍤¯1),[1+⍳2],[⍳3]exposed
      tex←(⍳6)(+⍤1)6×flat[tex]
      tex←,[⍳2]↑(∊exposed)/,textures[tex]
     
      buf←∊vert,tex
      p←#.SDL_MapGPUTransferBuffer device tb 1
      'Error mapping transfer buffer'#.Assert p
      skip←(vsize+isize)×≢tb_queue
      #.LSE_MemcpyF32(p+skip)buf(4×≢buf)
      #.LSE_MemcpyU32(p+skip+vsize)ind(4×≢ind)
      #.SDL_UnmapGPUTransferBuffer device tb
     
      vb←#.SDL_CreateGPUBuffer device(#.SDL_GPU_BUFFERUSAGE_VERTEX vsize 0)
      ib←#.SDL_CreateGPUBuffer device(#.SDL_GPU_BUFFERUSAGE_INDEX isize 0)
      'Error creating chunk vertex and index buffers'#.Assert vb ib
     
      tb_queue,←⊂vb ib tb skip
      chunks⍪←vb ib(≢ind)
    ∇

    ∇ Copy_chunks(device pass);vb;ib;tb;skip
      :For (vb ib tb skip) :In tb_queue
          #.SDL_UploadToGPUBuffer pass(tb skip)(vb 0 vsize)1
          #.SDL_UploadToGPUBuffer pass(tb(skip+vsize))(ib 0 isize)1
      :EndFor
     
    ∇



:EndNamespace
